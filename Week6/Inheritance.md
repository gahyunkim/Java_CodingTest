## 상속
### 1) 상속
```java
class Childclass extends Parentclass {
  // 여기에 필드 추가
  // 여기에 메소드 추가
}
``` 
- 상속 = 기존에 존재하는 클래스로부터 코드와 데이터를 이어받고 자신이 필요한 기능을 추가하는 기법
- 이미 작성된 검증된 소프트웨어를 재사용할 수 있어서 신뢰성 있는 소프트웨어를 손쉽게 개발, 유지 보수 할 수 있게 해주는 중요한 기술
- 여러 클래스에 공통적인 코드들을 하나의 클래스로 모을 수 있어서 코드 중복을 줄일 수 있음
- 부모 클래스는 자식 클래스의 일반화된 버전 = 슈퍼 클래스
- 자식 클래스는 부모 클래스의 특별한 버전 = 서브 클래스
- extends를 써주고 부모 클래스의 이름을 적어주면 상속할 수 있음.
- extends는 확장 파생한다는 의미 + 부모 클래스를 확장해 자식 클래스를 작성한다

```java
public class Car {  // Car이라는 클래스 = 부모 클래스로 사용됨
  int speed;
  public void setSpeed(int speed) {
    this.speed = speed;
  }
}

public cass SportsCar extends Car { // 부모 클래스인 Car를 사용하는 자식(서브 클래스) SportsCar를 만들었음
  boolean turbo;
  public void setTurbo(boolean flag) {
    turbo = flag;
  }
}
``` 
- 자식 클래스는 부모 클래스를 상속받으면, 부모 클래스의 필드와 메소드를 자유롭게 사용할 수 있음
- 사용하는 것 뿐 아니라 자신만의 필드와 메소드 추가할 수도 있음
- 상속의 강점 = 부모 클래스로부터 상속된 특징들을 자식 클래스에서 추가, 교체, 상세화 시킬 수 있음

__상속을 사용하는 이유__
1) 새로운 클래스를 생성해야 할 때 다른 클래스에 이미 존재하는 내용을 사용하는 것이라면, 직접 작성할 필요 없이 이미 존재하는 클래스의 필드와 메소드를 재사용 할 수 있음
2) 중복되는 코드를 줄일 수 있음 = 

### 2) 상속과 접근 제어

__자바의 접근 제어 지정자 요약__ 
|접근 지정자|클래스|패키지|자식 클래스|전체 세계|상속 가능 여부|
|------|:---:|:---:|:---:|:---:|:---:|
|public|O|O|O|O|X|
|protected|O|O|O|X|O|
|없음|O|O|X|X|O|
|public|O|X|X|X|O|

- 상속시킬 멤버와 상속시키지 않을 멤버를 지정할 수 있음
- 부모 클래스가 private 접근 제어 연산자를 사용하는 경우에는 상속이 불가능하다

### 3) 메소드 오버라이딩
- 자식 클래스에서는 부모 클래스의 메소드 중에서 필요한 것을 다시 정의할 수 있음
- 메소드 오버라이딩은 상속에서 부모 클래스의 메소드를 변경하는 것이 필요할 때 사용함
- 메소드 오버라이딩 = 부모 클래스의 메소드를 자식 클래스가 자신의 필요에 의해 맞춰서 변경하는 것
- 주의) 메소드의 이름이나 매개 변수, 반환형은 동일해야 함
```java
public class Parent {
  public void print() {
    System.out.println("부모 클래스의 print() 메소드");
  }
}

public class Child extends Parent { // Parent의 슈퍼 즉, 부모 클래스를 상속함
  // 부모 클래스의 메소드를 오버라이딩 하고 있음
  public void print() {
    super.print();  // 오버라이딩 했을 경우에 super를 사용해서 부모 클래스의 메소드를 호출하고 있음
    System.out.println("자식 클래스의 print() 메소드");
  }
  public static void main(String[] args) {
    Child obj = new Child();
    obj.print();
  }
}

결과 = 부모 클래스의 print() 메소드
       자식 클래스의 print() 메소드
``` 
- super는 상속 관계에서 부모 클래스의 메소드나 필드를 명시적으로 참조하기 위해 사용함
- 부모 클래스의 메소드나 필드를 오버라이드 한 경우에 super를 사용하면 부모 클래스의 메소드나 필드를 호출할 수 있음
- 결과를 통해서 부모 클래스를 먼저 호출하고, 자식 클래스를 호출하는 모습을 볼 수 있다

### 4) 상속과 생성자
```java
class Base {
  public Base() {
    System.out.println("Base() 생성자");
  }
};

class Derived extends Base {
  public Derived() {
    System.out.println("Derived() 생성자");
  }
};

public class Test {
  public static void main(String[] args) {
    Derived r = new Derived();
  }
}

결과 = Base() 생성자
       Derived() 생성자
``` 
- 분명 Derived 객체를 생성했는데 Base 생성자도 호출되는 이유는 부모 클래스에서 상속된 부분과 자식 클래스가 추가한 부분이 합쳐져 있기 때문이다.
- 생성자의 호출순서는 부모 클래스의 생성자 -> 자식 클래스의 생성자 순서이다

__부모 클래스의 생성자를 호출하는 방법__
1) 명시적인 호출
=> 자식 클래스의 생성자에서 명시적으로 생성자를 호출함. super();를 사용해서 생성자를 호출한다
2) 묵시적인 호출
=> super();라는 호출 없이도 컴파일러가 자동적으로 호출하는 것

### 5) 추상 클래스
- 추상 클래스 = 완전하게 구현되어 있지 않은 메소드를 가지고 있는 클래스
- 메소드가 미완성이므로 객체를 생성할 수 없음
```java
public abstract class Animal {
  public abstract void move();  // 추상 메소드의 정의는 ;로 마무리됨
};
```
- 추상 클래스는 하나 이상의 추상 메소드를 가짐
- 추상 메소드 = 몸체가 없는 메소드를 의미함, move()도 내부에 어떤 내용을 가지고 있지 않은 추상 메소드임
- 추상 메소드는 항상 세미 콜론으로 종료되어야 함

### 6) 상속과 다형성
- 다형성 = 많은 모양이라는 의미로 주로 프로그래밍 언어에서 하나의 식별자로 다양한 타입을 처리하는 것을 의미함
- 다형성 = 동일한 코드로 다양한 차입의 객체를 처리할 수 있는 기법

### 7) Object 클래스
- Object 클래스를 제외하고는 모든 클래스는 부모 클래스를 가짐
- 자바에서 부모 클래스를 명시적으로 지정하지 않으면 Object 클래스의 자식 클래스로 암묵적으로 간주함
- 모든 클래스의 맨 위에는 Object 클래스가 존재함

