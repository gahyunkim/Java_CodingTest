## 클래스와 메소드 심층 탐구 
### 1) 접근 제어
```java
class Employee{
  String name;
  int regNumber;
}
``` 
- Employee라는 클래스 안에 선언된 변수들이 어디에서 사용될 것인지 정해야함. 여기저기서 막 사용되면 문제가 생길 수도 있음
- 접근 제어 = 클래스의 멤버에 접근하는 것을 제어 하는 것.
- public은 공용이라는 의미로 멤버 앞에 붙이면 누구나 자유롭게 접근할 수 있음
- private는 전용이라는 의미로 클래스 안에서만 접근이 가능함.
- protected는 멤버가 부모 클래스와 자식 클래스만 접근할 수 있도록 함
- public, private, protected라는 접근 지정자를 이용해서 접근을 제한함
- 아무것도 붙이지 않는 경우에는 default로 동일한 패키지 내에서만 접근이 가능 

__자바의 접근 제어 지정자 요약__ 
|접근 지정자|클래스|패키지|자식 클래스|전체 세계|
|------|:---:|:---:|:---:|:---:|
|public|O|O|O|O|
|protected|O|O|O|X|
|없음|O|O|X|X|
|public|O|X|X|X|

### 2) 접근자와 설정자
- 정보 은닉 = 구현의 세부 사항을 클래스 안에 감추는 것.
- 클래스 안의 데이터를 외부에서 마음대로 사용하지 못하도록 하려면 private 접근 지정자를 사용하는 것이 좋음
- But, 클래스 안에 저장된 필드 값이 꼭 필요한 경우에는 특수한 메소드를 이용하면 된다.
- 필드값을 반환하는 __접근자(getters)__ 와 필드값을 설정하는 __설정자(setters)__ 가 있음 

__접근자와 설정자를 사용하는 이유__ 
1) 접근자와 설정자를 사용해야나중에 클래스를 업그레이드 할 때 편함
2) 접근자에서 매개 변수를 통해 잘못된 값이 넘어오는 경우, 이를 사전에 차단할 수 있음
3) 필요할 때마다 필드값을 계산하여 반환할 수 있음
4) 접근자만을 제공하면 자동적으로 읽기만 가능한 필드 만들 수 있음

### 3) 생성자
- 생성자 = 객체가 생성될 때 객체를 초기화하는 특수한 메소드
- 생성자의 이름은 클래스 이름과 동일
- 일반 메소드와 흡사하지만 반환값을 가지지 않고 생성자의 이름 앞에 아무것도 붙이지 않는다
- 생성자는 주로 필드에 초기값을 부여할 때 많이 사용됨
```java
public class MyCounter {
  int counter;
  MyCounter() {   // MyCounter의 생성자
    counter = 1;
  }
}

public class MyCounterTest {
  public static void main(String args[]) {
    MyCounter obj1 = new MyCounter();
    MyCounter obj2 = new MyCounter();
    System.out.println("객체 1의 counter = " + obj1.counter);
    System.out.println("객체 2의 counter = " + obj2.counter);
  }
}
``` 
- 위의 MyCounter클래스에서 클래스의 이름과 동일한 생성자를 생성했음.
- 생성자 안에서는 필드 counter를 1로 초기화하고 있음 => 생성자 = 초기화를 하기 위한 특별한 메소드
- 생성자는 객체가 생성될 떄 new에 읭해서 생성됨

### 4) 생성자 오버로딩
```java
public class Student{
  private int number;
  private String name;
  private int age;
  
  Student() {   // 생성자 1 생성
    number = 100;
    name = "New Student";
    age = 18;
  }
  
  Student(int number, String name, int age) {   // 매개변수가 있는 생성자 2 생성
    this.number = number;
    this.name = name;
    this.age = age;
  }
}

public class StudentTest {
  public static void main(String args[]) {
    Student obj1 = new Student();   // 첫번째 생성자 매개변수가 없는 생성자를 호출
    Student obj2 = new Student(111,"Kim",25); // 매개변수가 있는 두번째 생성자를 호출
  }
}
``` 
- 생성자는 몇개라도 오버로딩 할 수 있지만, 매개변수는 다르게 해야함
- this = 메소드나 생성자에서는 this를 이용해 현재 객체를 나타냄.
- this를 이용해서 현재 객체의 어떤 멤버도 참조할 수 있음.

### 5) 다른 필드 초기화 방법
```java
public class Hotel {
  public int capacity = 10;
  private boolean full = false;
}
```
- 클래스 안에 필드를 선언할 때 초기화 하기
- 초기값이 미리 알려져 있고 한 줄에 적을 수 있다면 효과적인 방법이지만, 반복 루프나 오류 처리와 같은 문장들을 넣을 수는 없음.
- 필드는 생성자에서 초기화하는 것이 정상임 + 인스턴스 초기화 블록으로 인스턴스 변수를 초기화할 수 있음
```java
public class Car {
  int speed;
  
  Car() {
    System.out.println("속도는 "+speed);
  }
  
  // 인스턴스 초기화 블록은 생성자에 복사됨
  {
    speed = 100;  // 필드 초기화 블록을 이용해서 생성자에 복사
  }
}
```
- 어떤 생성자가 선택되든지 상관없이 어떤 공통적인 코드를 실행하고자 할 때 편리하고, 무멱 클래스에서 초기화를 할 때도 필요하다

### 6) 메소드로 객체 전달하고 반환하기
- 자바에서 기본적으로 인수에서 매개변수로 값이 전달되는 방법은 __"값에 의한 호출"__ 이라고 함
- 전달하는 인수가 기초 변수인 경우에는 인수의 값이 매개 변수로 복사됨
- int, double과 같은 기초형을 메소드로 전달하는 경우에도 "값에 의한 호출"로 전달됨
- But, 객체를 메소드로 전달하는 경우에는 매우 복잡한 상황이됨
- 참조 변수 = 참조값(주소)를 가지고 있음
- 참조 변수의 경우 참조값이 복사되어서 매개변수로 전달됨. 따라서 인수와 매개변수 모두 동일한 객체를 가리키게 되는 것

### 7) 정적 멤버
- 정적 멤버 혹은 클래스 멤버 = 자바에서는 객체를 통하지 않고 사용할 수 있는 멤버를 생성할 수 있음 + 모든 객체를 통틀어서 하나만 생성되고 모든 객체가 이것을 공유함
- 인스턴스 변수 = 인스턴스마다 별도로 생성되는 변수, 각각의 객체들은 자신만의 변수를 가짐. 
- 정적 변수 = 하나의 클래스에 하나만 존재함, 객체보다는 클래스와 연결되어 있어 클래스 변수라고도 함.
- ex) Television의 클래스의 정적 멤버 count에 100을 대입하려면 Television.count=100; 이라고 적어주면 된다 

__정적 멤버 사용시 주의할 점__ 
1) 객체가 생성되지 않은 상태에서 호출되는 메소드이므로 객체 안에서만 존재하는 인스턴스 변수들은 사용할 수 없음
2) 정적 메소드에서 인스턴스 메소드를 호출하면 오류가 됨
3) 정적 메소드에서 정적 메소드를 호출하는 것은 가능함. 정적 메소드는 this 키워드를 사용할 수 없음 + this가 참조할 인스턴스가 없기 때문

### 8) 내장 클래스
- 외부 클래스 = 내부에 클래스를 가지고 있는 클래스
- 내부 클래스 = 클래스 내부에 포함되는 클래스






